###############

rule glmnet_extract:
    input:
        m8 = config["project_path"] + "pipeline_output/RESULTS_DB/{condition}_results.m8",
        fasta = config["project_path"] + "pipeline_output/kmdiff_output/{condition}_kmers.unitigs.fa"
    output:
        config["project_path"] + "pipeline_output/glmnet/{condition}_unclassified.unitigs.fa"
    params:
        output = config["project_path"] + "pipeline_output/glmnet/",
        script_path = config['src_path'] + "scripts/find_unaligned.sh"
    shell:
        """
        bash {params.script_path} --fasta {input.fasta} --m8 {input.m8} --output {params.output}
        mv {params.output}/unclassified.unitigs.fa {output}
        """


############## RENOMMER LES FICHIERS DE SORTIE POUR QUE CA CORRESPONDE
rule glmnet_pval_agg:
    input:
        unitigs = config["project_path"] + "pipeline_output/kmdiff_output/{condition}_unclassified.unitigs.fa",
        kmers = config["project_path"] + "pipeline_output/kmdiff_output/{condition}_kmers.fasta"
    output:
        config["project_path"] + "pipeline_output/glmnet/{condition}_unclassified.aggregated.fa"
    params:
        output = config["project_path"] + "pipeline_output/glmnet/",
        script_path = config['src_path'] + "scripts/pvalues_agg.py"
    conda:
        config["src_path"] + "env/python.3.10.yaml"
    shell:
        """
        python3 {params.script_path} -k {input.kmers} -u {input.unitigs} -o {params.output}
        mv {params.output}/unitigs.aggregated_pvalues.fa {output}
        """

rule glmnet_matrix:
    input:
        case = config["project_path"] + "pipeline_output/glmnet/case_unclassified.aggregated.fa",
        control = config["project_path"] + "pipeline_output/glmnet/control_unclassified.aggregated.fa",
        matrix = config["project_path"] + "pipeline_output/kmdiff_output/significant_kmers_matrix.txt"
    output:
        config["project_path"] + "pipeline_output/glmnet/top_kmers.tsv"
    params:
        output = config["project_path"] + "pipeline_output/glmnet/",
        script_path = config['src_path'] + "scripts/matrix_unknown_kmers.sh"
    shell:
        """
        bash {params.script_path} -i {input.case},{input.control} -m {input.matrix} -o {params.output}
        """


rule glmnet_class:
    input:
        matrix = config["project_path"] + "pipeline_output/glmnet/top_kmers.tsv",
        fof = config["fof"] 
    output:
        config["project_path"] + "pipeline_output/glmnet/best_model.txt", config["project_path"] + "pipeline_output/glmnet/heatmap.pdf", config["project_path"] + "pipeline_output/glmnet/accuracy.txt", config["project_path"] + "pipeline_output/glmnet/matrix.tsv"
    threads: 30
    params:
        output_folder = config["project_path"] + "pipeline_output/glmnet/",
        split = 0.75,
        script_path = config['src_path'] + "scripts/elasticNet_and_heatmap.R"
    conda:
        config["src_path"] + "env/glmnet.yaml"
    shell:
        """
        nb_control=$(grep -c -F "case" {input.fof})
        nb_case=$(grep -c -F "control" {input.fof})
        Rscript {params.script_path} -i {input.matrix} - {threads} --case "$nb_case" --control "$nb_control" --output {params.output_folder} -y {params.split}
        """
