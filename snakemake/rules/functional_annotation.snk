#############

rule annot_extract_candidates:
    input:
        config["project_path"] + "pipeline_output/kmdiff_output/{condition}_kmers.unitigs.fa"
    output:
        config["project_path"] + "pipeline_output/functional_annotation/{condition}_unitigs.filtered.fa"
    params:
        length = config["unitig_length"]
    log:
        stdout = config["project_path"] + "/pipeline_output/logs/annot_extract_candidates_{condition}.stdout",
        stderr = config["project_path"] + "/pipeline_output/logs/annot_extract_candidates_{condition}.stderr"
    conda:
        "../../env/seqkit.yaml"
    shell:
        """
        seqkit seq --min-len {params.length} -i {input} -o {output} 1> {log.stdout} 2> {log.stderr}
        """


rule prodigal:
    input:
        config["project_path"] + "pipeline_output/functional_annotation/{condition}_unitigs.filtered.fa"
    output:
        config["project_path"] + "pipeline_output/functional_annotation/{condition}_protein_translation.faa", config["project_path"] + "pipeline_output/functional_annotation/{condition}_coords.gbk"
    threads : config["threads"]
    params:
        coords = config["project_path"] + "pipeline_output/functional_annotation/{condition}_coords.gbk",
        translation = config["project_path"] + "pipeline_output/functional_annotation/{condition}_protein_translation.faa"
    log:
        stdout = config["project_path"] + "/pipeline_output/logs/prodigal_{condition}.stdout",
        stderr = config["project_path"] + "/pipeline_output/logs/prodigal_{condition}.stderr"
    conda:
        "../../env/prodigal.yaml"
    shell:
        """
        if [ ! -s {input} ]:
        then
            echo "No unitigs for gene sequence detection and translation." > {log.stdout}
            touch {output}
            exit 0
        else
            prodigal -p meta -i {input} -o {params.coords} -a {params.translation} > {log.stdout} 2> {log.stderr}
        fi
        """

#TODO: faire la rÃ¨gle par input, si l'un ou l'autre est nul.
rule microbeannotator:
    input:
        case = config["project_path"] + "pipeline_output/functional_annotation/case_protein_translation.faa",
        control = config["project_path"] + "pipeline_output/functional_annotation/control_protein_translation.faa"
    output:
        config["project_path"] + "pipeline_output/functional_annotation/metabolic_summary__heatmap.pdf", config["project_path"] + "pipeline_output/functional_annotation/metabolic_summary__barplot.pdf", config["project_path"] + "pipeline_output/functional_annotation/metabolic_summary__module_completeness.tab"
    threads: config["threads"]
    log:
        stdout = config["project_path"] + "logs/microbeannotator.stdout",
        stderr = config["project_path"] + "logs/microbeannotator.stderr"
    params:
        process = 1,
        database = config["microbeannotator_db_path"],
        output_folder = config["project_path"] + "pipeline_output/functional_annotation/"
    conda:
        "../../env/microbeannotator.yaml"
    shell:
        """
        if [ ! -s {input.case} ] && [ ! -s {input.control} ]
        then
            echo "No gene sequence detected." > {log.stdout}
            exit 0
        else if [ ! -s {input.case} ] && [ -s {input.control} ]
            echo "No unitigs to annotate in cases" > {log.stdout}
            microbeannotator  -p {params.process} -t {threads} -m diamond --database {params.database} --cluster rows -o {params.output_folder} -i {input.control} > {log.stdout} 2> {log.stderr}
        else if [ s {input.case} ] && [ ! -s {input.control} ]
            echo "No unitigs to annotate in controls" > {log.stdout}
            microbeannotator  -p {params.process} -t {threads} -m diamond --database {params.database} --cluster rows -o {params.output_folder} -i {input.case} > {log.stdout} 2> {log.stderr}
        else :
            microbeannotator  -p {params.process} -t {threads} -m diamond --database {params.database} --cluster rows -o {params.output_folder} -i {input.control} {input.case} > {log.stdout} 2> {log.stderr}
        fi
        """

rule summary_table:
    input:
        translation = config["project_path"] + "pipeline_output/functional_annotation/{condition}_protein_translation.faa",
        unitigs = config["project_path"] + "pipeline_output/functional_annotation/{condition}_unitigs.filtered.fa",
        kraken_output = config["project_path"] + "pipeline_output/taxonomy/kraken_{condition}.output"
    output:
        table = config["project_path"] + "pipeline_output/functional_annotation/{condition}_unitigs_to_clade_and_gene_functions.tsv",
        clades = config["project_path"] + "pipeline_output/taxonomy/{condition}_clades.tsv"
    params:
        output = config["project_path"] + "pipeline_output/functional_annotation/",
        script_path = config["src_path"] + "/scripts/sumup_table.py",
        annot = config["project_path"] + "pipeline_output/functional_annotation/annotation_results/{condition}_protein_translation.faa.annot",
        condition_name = lambda wildcards: wildcards.condition
    log:
        stdout = config["project_path"] + "logs/summary_table_{condition}.stdout",
        stderr = config["project_path"] + "logs/summary_table_{condition}.stderr"
    conda: 
        "../../env/python.3.10.yaml"
    shell:
        """
        if [ ! -s {input.translation} ]
        then
            echo "No table to built, no gene was detected" > {log.stdout}
            touch {output.clades} {output.table}
            exit 0
        else
    	    python3 {params.script_path} -a {params.annot} -g {input.translation} -o {params.output} -u {input.unitigs} -c {params.condition_name} -k {input.kraken_output} > {log.stdout} 2> {log.stderr}
            mv {params.output}/{params.condition_name}_clades.tsv  {params.output}/../taxonomy/
        fi
        """
    